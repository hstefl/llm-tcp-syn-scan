## TCP SYN scan detector

Before you read - this project is for education purposes only, in practice some a rules engine or lookup table would be more efficient.

### Goal

We aim to build a lightweight AI model that can automatically assess and explain the risk of **TCP SYN network scans** based on structured input metrics. These assessments are helpful in network security monitoring, anomaly detection, or automated SOC pipelines.

---

### TCP SYN Scan - theory
A TCP SYN Scan, also known as a half-open scan, is one of the most popular and efficient methods used in network reconnaissance and port scanning. It is used by security professionals and attackers alike to determine which TCP ports on a target system are open, closed, or filtered, without completing the full TCP three-way handshake.

#### Background: TCP Three-Way Handshake
To understand a SYN scan, it's crucial to understand how a TCP connection is normally established:

1. SYN (Synchronize): The client sends a SYN packet to the server to initiate a connection.
2. SYN-ACK (Synchronize-Acknowledge): The server responds with a SYN-ACK if the port is open.
3. ACK (Acknowledge): The client replies with an ACK to establish the connection.

This completes the three-way handshake and establishes a TCP connection.

### What is a TCP SYN Scan?
A TCP SYN Scan only sends the initial SYN packet and analyzes the response. It does not complete the handshake, which is why it's called a “half-open” scan.

Steps Involved in a SYN Scan:
1. Send SYN: The scanner (e.g., nmap) sends a TCP SYN packet to the target port.
2. Analyze the Response:
   - SYN-ACK: If the target responds with a SYN-ACK, the port is open.
   - RST (Reset): If the target responds with an RST, the port is closed.
   - No response or ICMP error: The port is likely filtered (e.g., by a firewall or router).
3. Abort Connection: If a SYN-ACK is received, the scanner sends an RST packet instead of an ACK, avoiding a full connection.

---

### What the Model Should Do
Given structured indicators from a time window (like SYN rate, port spread, etc.), the model should generate a precise, structured risk evaluation that includes:

 * Risk level (e.g., low, critical)
 * Scan type (e.g., distributed, targeted)
 * Suggested action
 * Explanation for the conclusion

In other words: Turn measured technical signals into interpreted cybersecurity insights.

---

### Training Data Format

Sequence-to-Sequence (Seq2Seq) format — similar to how translation systems are trained — because:

 * Each input maps to exactly one output.
 * The input and output are both textual and structured.
 * No generalization or creativity is needed — just precise mapping.

#### Input format:
A fixed schema with newline-separated metrics, like:

```
Evaluate TCP SYN scan risk:
Time Window: very-short
SYN Rate: high
SYN Percentage: dominant
Port Spread: many
ACK Response Rate: minimal response
Source Diversity: highly distributed
...
```

#### Output format:
Also fixed structure, newline-separated:

```
Scan Intensity: high
Risk Assessment: critical
Scan Archetype: distributed
Suggested Action: Alert SOC + Coordinate response
Explanation: high SYN rate; multiple ports targeted; highly distributed sources; minimal ACK responses; over very-short timeframe = distributed scanning attack
```

This mirrors a prompt–response relationship but with zero ambiguity:
the model is learning a deterministic mapping.

For more details about all fields read section "Dataset".

---

### Why This Format
- It supports **clean and deterministic learning**: each prompt has a single known good answer.
- It lets the model learn relationships between fields (e.g., high SYN + many ports = higher risk).

### Dataset
Dataset is generated by GPT o3 based on following prompt. Dataset captures all situation which can be observed. 
I generated them with LLM (GPT o3) with prompt stored in `in/PROMPT.md`. The dataset is in `in/dataset.csv`

### Model Chosen: google/flan-t5-base
It is a sequence-to-sequence model, ideal for translating structured prompts into structured assessments.
No need open-ended generation; goal is to have consistent, fixed-format responses.
Its behavior is more predictable (vs casual LMs).



---

### INSTALLATION
Dependencies
 * see https://pytorch.org/get-started/locally/
 * ```
   uv pip install torch --index-url https://download.pytorch.org/whl/cu128
   uv sync 
   ```
   


